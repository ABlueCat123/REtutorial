## 逆向目的与逆向手段
对于任何一件事，都可以问“是什么”、“为什么”和“怎么办”三个问题。在前言部分本文已经解释了逆向工程“是什么”的问题。于是本节便需要阐述为什么我们需要逆向工程(逆向目的)和怎么进行逆向工程(逆向手段)。

#### 本篇目的：
* 了解逆向工程的目的
* 了解常用的逆向手段

### 一、从Reflections on Trusting Trust<sup>[1]</sup>说起
什么样的代码是值得信任的？学术权威所写的代码？知名开发者所写的代码？教程作者所写的代码？亦或是你最好的朋友所写的代码？这些人所写的代码是不是能够值得被完全信任。以及即使源代码中没有任何问题，是不是就一定能保证获得的程序就是**绝对**安全的？

B语言的创始人、Unix系统的缔造者之一、1983年图灵奖的获得者Ken Thompson，在他获得图灵奖时的演讲中展示了一种可能存在的编译器后门：

首先存在一种程序，使得它可以输出自身(我们通常将其称为Quine)。然后如果我们在编译器内部加入一种Quine，其本质上是一种后门的话，便可以构建出**带有后门的编译器**。此时，一旦编译器被感染，即使人们使用被感染后的编译器来编译干净的编译器的源码，得到的还是带有后门的编译器。也就是说，无论用户是否自己下载源码**构建**一款软件，哪怕下载编译器源码来**构建**编译器，只要用户用到了编译器来**构建**，后门就有可能会存在于他的软件中，哪怕编译器源码和项目代码都是完全没问题的。

况且，后门并不一定来自于编译器的开发者。硬件、CPU等等，存在的后门层级越接近于底层，发现的难度越大。

因此，Ken提到：
> You can't trust code that you did not totally create yourself.

你并不能完全信任一份不是你自己写的代码。

### 二、逆向工程的目的
在前言部分已经介绍了逆向工程是通过一款已经实现了的软件，通过分析其运行逻辑等内容，获得一些开发者层面才能接触到的信息。一般来说，当我们确实需要逆向一款软件时，大部分会出于以下原因：
* **出于安全的需要**。举个例子，在Minecraft的插件、模组领域就大量运用了逆向工程。即使你可能并没有对逆向工程有很深的了解，你可能也会拥有一款逆向软件：Jd-gui。查看插件包不包含后门，是逆向工程的一个重要目的之一。
* **对软件实现的好奇**。当我们看到了一款软件，有一些功能十分有趣，但苦于不知道它是怎么做到的，那么逆向工程便可以帮助我们理解软件实现的内部逻辑。
* **修改实现代码**。想过汉化一款插件/模组吗？如果它提供了语言文件还好。如果没有提供，即语言文本可能写死在代码内，且没提供源代码的话，可能就需要修改内核来实现了。
* 

本篇参考资料：
1. Ken Thompson. Reflections on Trusting Trust. 原文地址：https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf 中译版：https://blog.csdn.net/r42135d1r2r4/article/details/94396236