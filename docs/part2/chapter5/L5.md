## 字节码指令介绍（三）
在本部分的最后，将讲解对象操作指令、操作数栈操作指令。

#### 本篇目的：
* 对象操作指令、操作数栈操作指令

### 一、对象操作指令
虽然类的对象和数组在Java虚拟机中都被认为是对象，但在指令集中有着完全不同的指令。

#### 对象创建指令
包含一个指令：`new`。

该指令后面跟两个字节，拼接起来的常量指向常量池中的一个`Class`型常量，代表该对象的类。

然而当对象创建后，还需要在之后使用`invoke`族指令调用构造方法后才会完成。当对象创建后，操作数栈自动压入一个该对象。

#### 数组对象创建指令
包含三个指令：`newarray`、`anewarray`、`multianewarray`。

对于`newarray`指令，创建一个基本类型数组对象。后面只跟一个字节，代表其类型。类型关系和字节如下表：

| 类型 | 字节 |
|:------------:|:-----------:|
| boolean      | 4           |
| char         | 5           |
| float        | 6           |
| double       | 7           |
| byte         | 8           |
| short        | 9           |
| int          | 10          |
| long         | 11          |

之后会在操作数栈顶弹出一个数字，为其大小，创建后将一个数组对象压入栈中。

对于`anewarray`指令，创建一个任意类型的数组对象。后面跟两个字节，拼接起来的常量指向常量池中的一个`Class`型常量，代表该数组元素对象的类。

之后会在操作数栈顶弹出一个数字，为其大小，创建后将一个数组对象压入栈中。

对于`multianewarray`指令，创建一个**包括基本数据类型在内**的任意类型的多维数组对象。后面跟两个字节，拼接起来的常量指向常量池中的一个`Class`型常量，代表该数组元素对象的“类”。

这个“类”将在常量池中以**描述符**的形式存储。例如：`char[][]`在常量池中所对应的就是`[[C`。

之后会在操作数栈顶弹出若干个数字（与维数相同），为其大小，创建后将一个数组对象压入栈中。

#### 字段访问指令
包含4条指令：`getstatic`、`putstatic`、`getfield`、`putfield`。

前两个对类的字段（static）进行操作，后者操作对象的字段（非static）。

操作过程与`load/store`指令类似：

`getstatic`后面跟两个字节，拼接后指向常量池中的一个`Fieldref`型的字段。将在操作数栈中加载这一字段。

`putstatic`后面跟两个字节，拼接后指向常量池中的一个`Fieldref`型的字段。操作数栈顶弹出一个字段，并在常量池中更新。

`getfield`后面跟两个字节，拼接后指向常量池中的一个`Fieldref`型的字段。将在操作数栈顶弹出一个对象，之后再在栈中加载该对象的字段。

`putfield`后面跟两个字节，拼接后指向常量池中的一个`Fieldref`型的字段。操作数栈顶弹出一个对象和一个字段，并在常量池中更新。

#### 数组长度指令
包含1条指令：`arraylength`。

该指令将在操作数栈顶弹出一个数组对象，对其取长度后压入栈中。对于多维数组，取**第一维的长度**。

#### 检查对象类型指令
包含2条指令：`instanceof`、`checkcast`。

`instanceof`关键字相信大家都不陌生。这个语句格式为：`a instanceof A`，`a`为一个对象，`A`为一个类，来检查`a`是不是`A`的一个实例。

对于这条字节码指令，前者后面跟两个字节，拼接后指向常量池中的一个`Class`类型的常量。代表`A`；将在操作数栈中弹出一个对象`a`，运算后将一个`int`型的数压入操作数栈中，`1`代表是，`0`代表不是。（实际上可以理解为压入一个`boolean`类型的结果）

`checkcast`关键字和前者十分类似。

对于这条字节码指令，前者后面跟两个字节，拼接后指向常量池中的一个`Class`类型的常量。代表`A`；将在操作数栈中弹出一个对象`a`，检查`a`是否可转换为`A`型。如果可以，将`a`重新压入栈，即操作数栈不变；否则抛出`ClassCastException`异常。

在强制类型转换过程，如果`checkcast`指令成功执行，那么局部变量表中**被转的类型的一个字段**会被直接`astore`为**转换的类型的字段**，具体可见下图：

![](pic/code.png)

![](pic/bytecode.png)

### 二、操作数栈操作指令
为了方便，Java虚拟机指令集中添加了直接操作操作数栈的指令：
* 弹栈指令：弹出一个或两个元素。

这里需要介绍I类基础类型与II类基础类型，可理解为其“长度”的不同。

`boolean byte char short int float 引用 返回地址` 这八种属于I类基础类型。

`long double`这两种属于II类基础类型。

对于`pop`指令，仅适用于I类基础类型，表示从操作数栈中弹出一个元素；

对于`pop2`指令，适用于两类基础类型，但语义稍有不同：对于II类基础类型，表示从操作数栈中弹出一个元素；对于I类基础类型，表示从操作数栈中弹出两个元素。

* 复制指令：从操作数栈顶复制元素。

包含`dup`、`dup_x1`、`dup_x2`、`dup2`、`dup2_x1`、`dup2_x2`六种指令。

对于`dup`指令，仅适用于栈顶元素为I类基础类型时。操作数栈变化为：`...| a | ` -> `...| a | a | `

对于`dup_x1`指令，仅适用于栈顶2元素都属于I类基础类型时。操作数栈变化为：`...| a | b |` -> `...| b | a | b |`

对于`dup_x2`，若栈顶3元素均为I类基础类型时，操作数栈变化为：`...| a | b | c | ` -> `...| c | a | b | c | `；若栈顶1元素（元素b）为I类，栈次顶1元素（元素a）为II类时，操作数栈变化为：`...| a | b |` -> `...| b | a | b |`

对于`dup2`指令：若栈顶两元素均为I类：操作数栈变化为：`...| a | b | ` -> `...| a | b | a | b |`；若栈顶元素为II类：操作数栈变化为：`...| a | ` -> `...| a | b |`

`dup2_x2`、`dup2_x3`与前面类似，但由于分I II类的原因，确实更加复杂。在逆向工作中很少用这两个，故略去。

* 交换指令：交换栈顶两元素：`swap`

至此，字节码指令介绍告一段落。

### 习题
1. 思考“常量池”中的“常量”真的是在整个运行周期内都不改变的吗？
2. 其他习题待补充……

本篇参考资料：
1. 《深入理解JAVA虚拟机：JVM高级特性与最佳实践（第3版）》 周志明著
